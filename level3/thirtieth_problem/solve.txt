This is a Linux crackme which features the use of kvm. It asks for a 0x20 bytes input, which has 256 bits. It then creates 256 kvm virutal machines. The first vm (called vm0 later), is similar to a controller which actually performs the varication algorithm. The rest 255 vms are called bit vm (by me) as each of them contains one input bit. Note the most significant bit of the input last char is treated differently but it does not pose a big challenge. 

The code for vm0 is at 0x3020. The code for bit vms is located at 0x3100. All the bit vms share the same code. Note both vm0 and bit vm executes 16-bit x86 code. Take note of this when you create the function; otherwise the disassembly will throw errors. 

The crackme executable communicates with the vms through the out instruction. The bit vm is simpler as it only handles bit operations. The vm0 is responsible to initialize the bit vms, fetch bit from them, perform certain operations on them and update the value of them. Eventually, vm0 takes the transformed bits and generate a 0x20-byte output. It is then compared with a constant 0x20-byte buffer. They must be equal. 

For every input bit, the vm0 takes the previous bit, the current bit, and the next bit and send them to the current bit vm to calculate a new bit value for the current bit. The calculation is at 0x14 (relative to its entry) in the bit vim. It is not complex, though a little bit twisted due to the vms. The update rule is:

new_bit = (curr_bit | next_bit) ^ prev_bit

The vm0 updates all the bits using the above rule. The update is done for 0x40 times. Eventually, it uses the generated bits to generate the 0x20 bytes buffer. 

I used z3 to reverse each of the update and repeat it for 0x40 times. It takes some time to re-implemnt the operations correctly due to inconvenience to debug the vms. So I first used the input "01234567890123456789012345678901" and get the output generated by the program. I debug my own implementation until my output is the same as the program's. After that, I take the desired output and use z3 to reverse the operation and it gives the correct flag: 

FLAG{1_h4rdw4r3_f0r_my_256_vms!}

This solution is quite high level as it does not contain any actually analysis of the code. However, I think one should be able to follow the code by himself once he has a big picutre for it. For detailed implementation, please refer to solve.py. 

xushengli@protonmail.com
