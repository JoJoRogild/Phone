# Yir's ELF - BCeption
## Solution

Cool Crackme, with a VM protection. No obfuscation, the program asks for the password with scanf(%u), then call the VM function at 0x400837.
If the VM return 4, the program prints "Well Done".

Let's analyse the VM.

First, we clearly see that the opcodes are at 0x400fe0.
The program initialize a "vm_stack" on the stack and vm_eip is at ptr_vm_stack + 0x118.
The program return -1 if eip > 0x55.

The rest is a classical VM with very few opcodes.
Here's a little disassembler, in python3

```python3
import os

opcodeshs = '1400010F04150F0E531401140214031404010813010937010A01010BF0010C0F010D900107AD15270E2C03EA07190107E915170E3703EA074807490107CB15470E4403EA073D073C073901071615370E5303EA160E'
opcodes = bytearray.fromhex(opcodeshs)
eip = 0
while eip < len(opcodes):
    op1 = opcodes[eip]
    op2 = opcodes[eip+1]
    print(hex(eip) + ": (", hex(op1) , hex(op2), ")")
    if op1 == 0x14:
        print("\tmov [ptrStack + ", hex(op2), "], [ptrStack + r8 + 0x12]")
        print("\tdec r8")
        eip += 2
    elif op1 == 0x1:
        print("\tmov [ptrStack + ", hex(op2), "], ", hex(opcodes[eip + 2]))
        eip += 3
    elif op1 == 0x15:
        print("\tmov ebx, [ptrStack + ", hex(op2 >> 4), "]")
        print("\tmov ecx, [ptrStack + ", hex(op2 & 0xf), "]")
        print("\tmov edx, 3")
        print("\tmov [ptrStack + 0xf], 0")
        print("\tmov [ptrStack + 0x10], 0")
        print("\tmov [ptrStack + 0x11], 0")
        print("\tcmp eax, ebx")
        print("\tmov [ptrStack + 0xf], ZF")
        eip +=2
    elif op1 == 0xe:
        print("\ttest [ptrStack + 0xf]")
        print("\tjnz", hex(op2))
        eip += 2
    elif op1 == 0x3:
        print("\tadd [ptrStack + ", hex(op2 >> 4), "], [ptrStack + ", hex(op2 & 0xf), "]")
        eip += 2
    elif op1 == 0x7:
        print("\txor [ptrStack + ", hex(op2 >> 4), "], [ptrStack + ", hex(op2 & 0xf), "]")
        eip += 2
    elif op1 == 0x16:
        print("\tmov eax, [ptrStack + ", hex(op2), "]")
        print("\tret")
        eip += 2
    else:
        print("whats that opcode ? ", hex(op1))
        os._exit(0)
```

And here's its output

```
0x0: ( 0x14 0x0 )
	mov [ptrStack +  0x0 ], [ptrStack + r8 + 0x12]
	dec r8
0x2: ( 0x1 0xf )
	mov [ptrStack +  0xf ],  0x4
0x5: ( 0x15 0xf )
	mov ebx, [ptrStack +  0x0 ]
	mov ecx, [ptrStack +  0xf ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x7: ( 0xe 0x53 )
	test [ptrStack + 0xf]
	jnz 0x53
0x9: ( 0x14 0x1 )
	mov [ptrStack +  0x1 ], [ptrStack + r8 + 0x12]
	dec r8
0xb: ( 0x14 0x2 )
	mov [ptrStack +  0x2 ], [ptrStack + r8 + 0x12]
	dec r8
0xd: ( 0x14 0x3 )
	mov [ptrStack +  0x3 ], [ptrStack + r8 + 0x12]
	dec r8
0xf: ( 0x14 0x4 )
	mov [ptrStack +  0x4 ], [ptrStack + r8 + 0x12]
	dec r8
0x11: ( 0x1 0x8 )
	mov [ptrStack +  0x8 ],  0x13
0x14: ( 0x1 0x9 )
	mov [ptrStack +  0x9 ],  0x37
0x17: ( 0x1 0xa )
	mov [ptrStack +  0xa ],  0x1
0x1a: ( 0x1 0xb )
	mov [ptrStack +  0xb ],  0xf0
0x1d: ( 0x1 0xc )
	mov [ptrStack +  0xc ],  0xf
0x20: ( 0x1 0xd )
	mov [ptrStack +  0xd ],  0x90
0x23: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0xad
0x26: ( 0x15 0x27 )
	mov e0x0: ( 0x14 0x0 )
	mov [ptrStack +  0x0 ], [ptrStack + r8 + 0x12]
	dec r8
0x2: ( 0x1 0xf )
	mov [ptrStack +  0xf ],  0x4
0x5: ( 0x15 0xf )
	mov ebx, [ptrStack +  0x0 ]
	mov ecx, [ptrStack +  0xf ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x7: ( 0xe 0x53 )
	test [ptrStack + 0xf]
	jnz 0x53
0x9: ( 0x14 0x1 )
	mov [ptrStack +  0x1 ], [ptrStack + r8 + 0x12]
	dec r8
0xb: ( 0x14 0x2 )
	mov [ptrStack +  0x2 ], [ptrStack + r8 + 0x12]
	dec r8
0xd: ( 0x14 0x3 )
	mov [ptrStack +  0x3 ], [ptrStack + r8 + 0x12]
	dec r8
0xf: ( 0x14 0x4 )
	mov [ptrStack +  0x4 ], [ptrStack + r8 + 0x12]
	dec r8
0x11: ( 0x1 0x8 )
	mov [ptrStack +  0x8 ],  0x13
0x14: ( 0x1 0x9 )
	mov [ptrStack +  0x9 ],  0x37
0x17: ( 0x1 0xa )
	mov [ptrStack +  0xa ],  0x1
0x1a: ( 0x1 0xb )
	mov [ptrStack +  0xb ],  0xf0
0x1d: ( 0x1 0xc )
	mov [ptrStack +  0xc ],  0xf
0x20: ( 0x1 0xd )
	mov [ptrStack +  0xd ],  0x90
0x23: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0xad
0x26: ( 0x15 0x27 )
	mov ebx, [ptrStack +  0x2 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x28: ( 0xe 0x2c )
	test [ptrStack + 0xf]
	jnz 0x2c
0x2a: ( 0x3 0xea )
	add [ptrStack +  0xe ], [ptrStack +  0xa ]
0x2c: ( 0x7 0x19 )
	xor [ptrStack +  0x1 ], [ptrStack +  0x9 ]
0x2e: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0xe9
0x31: ( 0x15 0x17 )
	mov ebx, [ptrStack +  0x1 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x33: ( 0xe 0x37 )
	test [ptrStack + 0xf]
	jnz 0x37
0x35: ( 0x3 0xea )
	add [ptrStack +  0xe ], [ptrStack +  0xa ]
0x37: ( 0x7 0x48 )
	xor [ptrStack +  0x4 ], [ptrStack +  0x8 ]
0x39: ( 0x7 0x49 )
	xor [ptrStack +  0x4 ], [ptrStack +  0x9 ]
0x3b: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0xcb
0x3e: ( 0x15 0x47 )
	mov ebx, [ptrStack +  0x4 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x40: ( 0xe 0x44 )
	test [ptrStack + 0xf]
	jnz 0x44
0x42: ( 0x3 0xea )
	add [ptrStack +  0xe ], [ptrStack +  0xa ]
0x44: ( 0x7 0x3d )
	xor [ptrStack +  0x3 ], [ptrStack +  0xd ]
0x46: ( 0x7 0x3c )
	xor [ptrStack +  0x3 ], [ptrStack +  0xc ]
0x48: ( 0x7 0x39 )
	xor [ptrStack +  0x3 ], [ptrStack +  0x9 ]
0x4a: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0x16
0x4d: ( 0x15 0x37 )
	mov ebx, [ptrStack +  0x3 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x4f: ( 0xe 0x53 )
	test [ptrStack + 0xf]
	jnz 0x53
0x51: ( 0x3 0xea )
	add [ptrStack +  0xe ], [ptrStack +  0xa ]
0x53: ( 0x16 0xe )
	mov eax, [ptrStack +  0xe ]
	retbx, [ptrStack +  0x2 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x28: ( 0xe 0x2c )
	test [ptrStack + 0xf]
	jnz 0x2c
0x2a: ( 0x3 0xea )
	add [ptrStack +  0xe ], [ptrStack +  0xa ]
0x2c: ( 0x7 0x19 )
	xor [ptrStack +  0x1 ], [ptrStack +  0x9 ]
0x2e: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0xe9
0x31: ( 0x15 0x17 )
	mov ebx, [ptrStack +  0x1 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x33: ( 0xe 0x37 )
	test [ptrStack + 0xf]
	jnz 0x37
0x35: ( 0x3 0xea )
	add [ptrStack +  0xe ], [ptrStack +  0xa ]
0x37: ( 0x7 0x48 )
	xor [ptrStack +  0x4 ], [ptrStack +  0x8 ]
0x39: ( 0x7 0x49 )
	xor [ptrStack +  0x4 ], [ptrStack +  0x9 ]
0x3b: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0xcb
0x3e: ( 0x15 0x47 )
	mov ebx, [ptrStack +  0x4 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x40: ( 0xe 0x44 )
	test [ptrStack + 0xf]
	jnz 0x44
0x42: ( 0x3 0xea )
	add [ptrStack +  0xe ], [ptrStack +  0xa ]
0x44: ( 0x7 0x3d )
	xor [ptrStack +  0x3 ], [ptrStack +  0xd ]
0x46: ( 0x7 0x3c )
	xor [ptrStack +  0x3 ], [ptrStack +  0xc ]
0x48: ( 0x7 0x39 )
	xor [ptrStack +  0x3 ], [ptrStack +  0x9 ]
0x4a: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0x16
0x4d: ( 0x15 0x37 )
	mov ebx, [ptrStack +  0x3 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x4f: ( 0xe 0x53 )
	test [ptrStack + 0xf]
	jnz 0x53
0x51: ( 0x3 0xea )
	add [ptrStack +  0xe ], [ptrStack +  0xa ]
0x53: ( 0x16 0xe )
	mov eax, [ptrStack +  0xe ]
	ret
```

Well, the output is pretty clear, the VM check for each bytes of our input int, and add 1 to ptr_vm_stack + 0xe if the comparaison is correct. We know that the return of the VM must be 4, so we need to pass the 4 comparaisons. The bytes of our input are at ptr_vm_stack + 1..4

The first one:

```
0x23: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0xad
0x26: ( 0x15 0x27 )
	mov ebx, [ptrStack +  0x2 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x28: ( 0xe 0x2c )
	test [ptrStack + 0xf]
	jnz 0x2c
```

Ok, so byte2 == 0xad

Then the second comparaison:

```
0x2c: ( 0x7 0x19 )
	xor [ptrStack +  0x1 ], [ptrStack +  0x9 ]
0x2e: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0xe9
0x31: ( 0x15 0x17 )
	mov ebx, [ptrStack +  0x1 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x33: ( 0xe 0x37 )
	test [ptrStack + 0xf]
	jnz 0x37
```

and we have byte1 ^ 0x37 == 0xe9.

Then the third comparaison:

```
0x37: ( 0x7 0x48 )
	xor [ptrStack +  0x4 ], [ptrStack +  0x8 ]
0x39: ( 0x7 0x49 )
	xor [ptrStack +  0x4 ], [ptrStack +  0x9 ]
0x3b: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0xcb
0x3e: ( 0x15 0x47 )
	mov ebx, [ptrStack +  0x4 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x40: ( 0xe 0x44 )
	test [ptrStack + 0xf]
	jnz 0x44
```

And the last one:

```
0x44: ( 0x7 0x3d )
	xor [ptrStack +  0x3 ], [ptrStack +  0xd ]
0x46: ( 0x7 0x3c )
	xor [ptrStack +  0x3 ], [ptrStack +  0xc ]
0x48: ( 0x7 0x39 )
	xor [ptrStack +  0x3 ], [ptrStack +  0x9 ]
0x4a: ( 0x1 0x7 )
	mov [ptrStack +  0x7 ],  0x16
0x4d: ( 0x15 0x37 )
	mov ebx, [ptrStack +  0x3 ]
	mov ecx, [ptrStack +  0x7 ]
	mov edx, 3
	mov [ptrStack + 0xf], 0
	mov [ptrStack + 0x10], 0
	mov [ptrStack + 0x11], 0
	cmp eax, ebx
	mov [ptrStack + 0xf], ZF
0x4f: ( 0xe 0x53 )
	test [ptrStack + 0xf]
	jnz 0x53
```

So here are the conditions:

```
x1 ^ 0x37 == 0xe9 -->               0xde
x2 == 0xad -->                      0xad
x3 ^ 0x90 ^ 0xf ^ 0x37 == 0x16 -->  0xbe
x4 ^ 0x13 ^ 0x37 == 0xcb -->        0xef
```

The solution is the base10 value of 0xdeadbeef !

```
~ python -c "print(0xdeadbeef)"
3735928559
~ ./uck 
[***************************]
[          Welcome          ]
[***************************]
[ ? password ] > 3735928559
[ +   ok     ] > Well done :-D
```

Thanks for the challenge !
